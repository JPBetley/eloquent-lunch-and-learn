Eloquent - Bisnow Lunch and Learn

2024-04-11

## Notes
### Goal
Showcase some random goodies for working with Eloquent, as it's much more powerful than just the database throughput layer, and can be used to great effect.

- Highlight some newer features and configurations that you may not have seen
- Demonstrate some potential performance improvements for your models
- Demonstrate some useful ways to get specific data from your models, especially when it comes to relations
- Highlight 4 pitfalls that I've encountered working with our actual applications
- If time, touch on some features that I don't have code examples for

Credit to Jonathan Reinink who made the Eloquent Performance Patterns course, from where I learned a good amount of this stuff
### Global Config and Eager Loading
`Model::shouldBeStrict()` and `DB::prohibitDestructiveCommands()` both useful IN THE RIGHT CONTEXT. Use ENV controls for this

#### Demo
1. Show good query
2. Remove eager load and show
3. Restore eager load, talk about $with on `Company` and how many models it loads
4. Remove, and show `AppServiceProviderConfig`
5. Restore

Scopes are extremely useful tools for centralizing query operations, not just for where clauses. Use them often

### One of a Many Relationship
Many cases where you want the last item in a relation for a record

#### Demo
1. Users now have a logins HasMany relationship for all of their login records
2. We can display the latest login record by grabbing it in the view, but this will hit our lazy load issue
3. Eager load the logins, less queries, but way more data than we actually need
4. We could do something like adding a FK to the user that is an id of the last login ID, but we can do better with Eloquent and SUB QUERIES
5. Remove eagerload for this
```
->addSelect(['last_login_at' => Login::select('created_at')  
->whereColumn('user_id', 'users.id')  
->latest()  
->take(1)  
])
```
6. Try `->diffForHumans()` and break, add `->withCasts(['last_login_at' => 'datetime'])` to the controller
7. When this works, move to a scope, showing off new attribute, and simplification in controller `withLastLoginAt()`
8. Move to next commit
9. Imagine we want to fetch multiple fields from related model. We have IP address, as another subquery property. Tedious if we want multiple. What we want is the full model
10. Move forward one commit
11. Intermediary step: create a scope that adds a dynamic ID property, and then a HasOne relationship using this new FAKE foreign key ID generated by a sub query. From Laravel's perspective it works just like a real FK id. But we can do better
12. Move forward one commit
13. Laravel introduced HasOne OfMany functions that exist for this exact purpose. `latestOfMany` is just shorthand for ordering by created_at columns. Regular `ofMany` can use any query you'd like

### Relation Ordering, Joins, and Order By
Move ahead commit
There are certainly instances where you want to order by a relation's column. The easiest option for doing this would be through a join
1. Show the query using a join
2. Move ahead commit
3. Show query using order by sub-query. Avoids potential join pitfalls, but comes at a performance cost
4. Move back commit, and comment the select, showing the bad data. Highlight real use case of this issue

### Pitfall #1 : join columns
App has slack alerts if any emails fail to send to ESP. Historically, the ID of the record shown did not match the actual ID of the bad email, causing confusion. The issue was because of a JOIN. Eloquent will take the last of any duplicate property names that appear in a join statement. So instead of the ID of the primary record, the model had the id of the JOIN record instead. This was refactored to use a `whereHas` instead, circumventing the whole issue. Join wasn't needed since this was small performance impact in a background process

Joins are incredibly powerful, but be sure you're working with them correctly when it comes to Eloquent Models. My rule of thumb is, if I'm adding a join, I always add a `model.*` select statement to avoid issues
### Pruning
Test data has 2.5 million logins. Legal says we only need to keep up to the past year's worth of logins. Pruning will do the heavy lifting

Move forward one commit

Prunable vs MassPrunable: Mass will be wholly more efficient, as it solely executes the DB statement. Prunable will fetch the models, allowing pruning and delete events to be triggered and acted upon, in case there is additional behavior that needs to happen when these records are deleted. Use MassPrunable first unless you have a real use case for Prunable, as it will be vastly more efficient

Run `a model:prune --pretend` to show example

Show the scheduler `console.php`

### Pitfall #2: Nesting Relations
Here's an example of another pitfall I've found and remedied in a few places, using query builder calls in attributes to simplify relations

Move forward commit, explain new posts and tags

Highlight the query issues with the attribute, firing up to 3 additional queries per attribute access, first row fires 6 additional queries

move forward commit, cache the result in an attribute. Halves the number of queries, because we only fire once no matter how many times accessed in the view

move forward commit, use collection property, not the query builder. halves the queries again, turning it into our normal N+1. Easily fixed with eager loading `->with('postTags')`

### Resources
Demonstrate conditional resource stuff
move forward commit, demo conditional field
move forward commit, showcase relationship
move forward commit, showcase conditional. Add `->with('postTags')` to load
`nah` move forward commit, showcase conditional query param

### Pitfall #3: Model global event dispatcher and guarding
Real example that haunted me for months when first starting here. On dev/beta, observers would occasionally just stop working. I would deploy a fix, immediately test, and it worked. But after some time, it all broke.

Had to do with event dispatchers and unguarding for models.

The problem is that the before settings occurred on a worker, and so eventually, this job would run, unsetting events for ALL models (this is not just specific to the one model), causing this breaking issue. The fix was to ensure the restoration of this.

### Route Binding and Slugs
http://eloquent-lunch-and-learn.test/posts/magni-at-vel-ut-ex-dolor
Often, we want to look up a record by url using a field other than the id, like a post slug

Beyond that, some times we need to ensure parent-child scope for models, which we can do with scope bindings

### Casts
An incredibly powerful tool in Eloquent, with new features added every day
Stringable for post data
User with encrypted data and enum collections

### Factories and Seeding
Stupid useful for setting up test data, especially in bulk (as I did for this demo)

`has` function for assiging

### Pitfall #4: Factory reusability
Move forward one commit
Show PostTag factory with create of related model
problem 1: create()->id creates the record EVEN IF IT IS UNUSED run `phpunit`
problem 2: firstOrFail will throw errors if seeded data doesn't exist. defeats the purpose of test factory

Solution: Just use `factory()` only. Laravel can determine if the factory needs to create an object, or if you've passed one in

### Other Eloquent things that might be of interest
- UUID/ULID primary keys
- New query helpers
    - future/past queries
    - simpler syntax for relation existence
    - Custom object casting
    - fillAndInsert to use bulk insert, but with some eloquent goodness